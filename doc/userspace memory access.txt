Эпиграф: "Все дебаггеры делают это"

Заметки по поводу чтения памяти процесса из пространства пользователя.

Да, читать память других процессов из пространства пользователя
возможно, так делает GDB, например. Вот, что про это известно. С
английского не перевожу полностью, но пояснения будут.

/proc/$pid/mem

If you try to read from the mem pseudo-file of another process, it
doesn't work: you get an ESRCH (No such process) error.

The permissions on /proc/$pid/mem (r--------) are more liberal than what
should be the case. For example, you shouldn't be able to read a setuid
process's memory. Furthermore, trying to read a process's memory while
the process is modifying it could give the reader an inconsistent view
of the memory, and worse, there were race conditions that could trace
older versions of the Linux kernel (according to this lkml thread,
though I don't know the details). So additional checks are needed:

     The process that wants to read from /proc/$pid/mem must attach to
     the process using ptrace with the PTRACE_ATTACH flag. This is what
     debuggers do when they start debugging a process; it's also what
     strace does to a process's system calls. Once the reader has
     finished reading from /proc/$pid/mem, it should detach by calling
     ptrace with the PTRACE_DETACH flag.
     
     The observed process must not be running. Normally calling
     ptrace(PTRACE_ATTACH, …) will stop the target process (it sends a
     STOP signal), but there is a race condition (signal delivery is
     asynchronous), so the tracer should call wait (as documented in
     ptrace(2)).

A process running as root can read any process's memory, without needing
to call ptrace, but the observed process must be stopped, or the read
will still return ESRCH.

Собственно, что здесь написано:

В procfs достаточно информации про распределение памяти процессов, но
надо иметь ввиду, что читать память придется все равно через ядро.

Главное: процесс должен быть остановлен, то есть маппинг его страниц
должен быть зафиксирован. В любом случае, чтение происходит через
procfs, то есть "из ядра". А ядро использует те же механизмы чтения
памяти процесса, что описаны в моем основном документе. Даже root не
всегда может прочесть содержимое памяти процесса в общем случае в любое
время.

Способ работы через procfs не очень эффективен, потому как содержимое
памяти сначала копируется (или отображается (mmap)) в ядро, а потом
копируется назад в пространство пользователя, но уже другому
процессу. Для отладчика такой режим допустим, но нам же работать на
живой системе.

И еще одно замечание. Вся работа с памятью и информация, относящаяся к
памяти всегда будет в procfs. Перенос этой информации в sysfs не
планируется. Sysfs от procfs мало чем отличаются с точки зрения
"изнутри". Procfs является более ранним компонентом ядра, и sysfs
задумывалась не как замена profs, а как нечто более структуированное.

В sysfs хранится информация об устройствах, шинах передачи данных,
загруженных модулях и всем том, что относится к систме и ядру, а не к
процессам.

Вывод: утилиту для проверки целостности процессов в пространстве
пользователя написать можно, но работать она будет как GDB-lite:
остановил процесс системным вызовом ptrace и прочитал
память. Эффективность такой утилиты сомнительна, а КПД всей ОС будет
стремиться к паровозному.



